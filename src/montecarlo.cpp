#include "../include/project/montecarlo.hpp"
#include "../include/project/functionevaluator.hpp"


// Function to evaluate the function using the Monte Carlo method
// for the original project over a hypercube domain
std::pair<double, double> montecarloIntegration(size_t n,
                                                const std::string &function,
                                                HyperCube &hypercube,
                                                double &variance)
{
    double total_value = 0.0;
    double total_squared_value = 0.0;
    double result = 0.0;
    std::vector<double> random_point_vector;
    random_point_vector.resize(hypercube.getDimension());

    std::cout << "Computing integral..." << std::endl;

    // Start the timer
    auto start = std::chrono::high_resolution_clock::now();

// The Monte Carlo method is parallelized using OpenMP to speed up the computation
// The points are generated by parallelizing the generation for each dimension
// The random point vector is used to store the value of each dimension of the random generated point
#pragma omp parallel private(result)
    {
        mu::Parser parser;
#pragma omp for reduction(+ : total_value, total_squared_value)
        for (size_t i = 0; i < n; ++i)
        {
            hypercube.generateRandomPoint(random_point_vector);

            result = evaluateFunction(function, random_point_vector, parser);
            parser.ClearVar();

            total_value += result;
            total_squared_value += result * result;
        }
    }

    // Calculate the integral
    hypercube.calculateVolume();
    double domain = hypercube.getVolume();
    double integral = total_value / static_cast<double>(n) * domain;

    // Stop the timer
    auto end = std::chrono::high_resolution_clock::now();

    // Calculate the variance
    variance = total_squared_value / static_cast<double>(n) - (total_value / static_cast<double>(n)) * (total_value / static_cast<double>(n));

    // Compute time taken
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    return std::make_pair(integral, duration.count());
}

// Function to evaluate the function using the Monte Carlo method
// for the original project over a hyperrectangle domain
std::pair<double, double> montecarloIntegration(size_t n,
                                                const std::string &function,
                                                HyperRectangle &hyperrectangle,
                                                double &variance)
{
    double total_value = 0.0;
    double total_squared_value = 0.0;
    double result = 0.0;
    std::vector<double> random_point_vector;
    random_point_vector.resize(hyperrectangle.getDimension());

    std::cout << "Computing integral..." << std::endl;

    // Start the timer
    auto start = std::chrono::high_resolution_clock::now();

// The Monte Carlo method is parallelized using OpenMP to speed up the computation
// The points are generated by parallelizing the generation for each dimension
// The random point vector is used to store the value of each dimension of the random generated point
#pragma omp parallel private(result)
    {
        mu::Parser parser;

#pragma omp for reduction(+ : total_value, total_squared_value)
        for (size_t i = 0; i < n; ++i)
        {
            hyperrectangle.generateRandomPoint(random_point_vector);
            if (!random_point_vector.empty())
            {
                result = evaluateFunction(function, random_point_vector, parser);
                parser.ClearVar();
                total_value += result;
                total_squared_value += result * result;
            }
            else
            {
                std::cout << "Error generating random point" << std::endl;
                i--;
            }
        }
    }

    // Calculate the integral
    hyperrectangle.calculateVolume();
    double domain = hyperrectangle.getVolume();
    double integral = total_value / static_cast<double>(n) * domain;

    // Stop the timer
    auto end = std::chrono::high_resolution_clock::now();

    // Calculate the variance
    variance = total_squared_value / static_cast<double>(n) - (total_value / static_cast<double>(n)) * (total_value / static_cast<double>(n));

    // Compute time taken
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    return std::make_pair(integral, static_cast<double>(duration.count()));
}

// Function to evaluate the function using the Monte Carlo method
// for the original project over a hypersphere domain
std::pair<double, double> montecarloIntegration(size_t n,
                                                const std::string &function,
                                                HyperSphere &hypersphere,
                                                double &variance)

{
    double total_value = 0.0;
    double total_squared_value = 0.0;
    double result = 0.0;
    std::vector<double> random_point_vector;
    random_point_vector.resize(hypersphere.getDimension());
    
    std::cout << "Computing integral..." << std::endl;

    // Start the timer
    auto start = std::chrono::high_resolution_clock::now();

// The Monte Carlo method is parallelized using OpenMP to speed up the computation
// The points are generated by parallelizing the generation for each dimension
// The random point vector is used to store the value of each dimension of the random generated point
#pragma omp parallel private(result)
    {
        mu::Parser parser;
#pragma omp for reduction(+ : total_value, total_squared_value)
        for (size_t i = 0; i < n; ++i)
        {
            hypersphere.generateRandomPoint(random_point_vector);

            if (random_point_vector[0] != 0.0)
            {
                result = evaluateFunction(function, random_point_vector, parser);
                parser.ClearVar();
                total_value += result;
                total_squared_value += result * result;
            }
            else
            {
                i--;
            }
        }
    }

    // Calculate the integral
    hypersphere.calculateVolume();
    double domain = hypersphere.getVolume();
    double integral = total_value / static_cast<double>(n) * domain;

    // Stop the timer
    auto end = std::chrono::high_resolution_clock::now();

    // Calculate the variance
    variance = total_squared_value / static_cast<double>(n) - (total_value / static_cast<double>(n)) * (total_value / static_cast<double>(n));

    // Compute time taken
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    return std::make_pair(integral, duration.count());
}
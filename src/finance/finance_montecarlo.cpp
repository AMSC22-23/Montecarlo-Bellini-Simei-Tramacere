#include "../../include/project/finance_montecarlo.hpp"


uint32_t xorshift(uint32_t seed)
{
    seed ^= seed << 13;
    seed ^= seed >> 17;
    seed ^= seed << 5;
    return seed;
}

// Function to calculate the option price prediction using the Monte Carlo method
// The function is the core of the finance oriented project, which is used to predict
// the option price prediction using the Monte Carlo method.
std::pair<double, double> montecarloPricePrediction(size_t points,
                                                    const std::string &function,
                                                    HyperRectangle &hyperrectangle,
                                                    const std::vector<const Asset *> &assetPtrs,
                                                    const double std_dev_from_mean,
                                                    double &variance,
                                                    std::vector<double> coefficients,
                                                    const double strike_price,
                                                    std::vector<double> &predicted_assets_prices)
{
    double C = 0.0;
    double C0 = 0.0;
    double total_value = 0.0;
    double total_value1 = 0.0;
    double total_value2 = 0.0;
    double total_squared_value = 0.0;
    double total_squared_value1 = 0.0;
    double total_squared_value2 = 0.0;
    double result1 = 0.0;
    double result2 = 0.0;
    double r = 0.05;
    double T = 1.0;
    auto start = std::chrono::high_resolution_clock::now();

// Parallelize the Monte Carlo method for the finance project
// by using OpenMP to speed up the computation
// The points are generated by parallelizing the generation for each asset
// The random point vector is used to store the value of each asset
// of the random generated point
#pragma omp parallel
    {
        double total_value_thread1 = 0.0;
        double total_value_thread2 = 0.0;
        double total_squared_value_thread1 = 0.0;
        double total_squared_value_thread2 = 0.0;
        std::vector<double> random_point_vector1(assetPtrs.size(), 0.0);
        std::vector<double> random_point_vector2(assetPtrs.size(), 0.0);
#pragma omp for reduction(+ : total_value, total_squared_value)
        for (size_t i = 0; i < points/2; ++i)
        {

            generateRandomPoint(random_point_vector1, random_point_vector2, assetPtrs, std_dev_from_mean, predicted_assets_prices);

            // Check if the random point vector is not null
            if (random_point_vector1[0] != 0.0 && random_point_vector2[0] != 0.0 )
            {

                result1 = 0.0;
                result2 = 0.0;

                // Evaluate the payoff function with the random point
                for (size_t i = 0; i < random_point_vector1.size(); ++i)
                {
                    result1 += random_point_vector1[i];
                    result2 += random_point_vector2[i];
                    // predicted_assets_prices[i] += random_point_vector[i];
                }

                result1 = std::max(0.0, (result1 - strike_price));
                result2 = std::max(0.0, (result2 - strike_price));
                //std::cout << "result: " << result << std::endl;

                total_value_thread1 += result1;
                total_value_thread2 += result2;
                total_squared_value_thread1 += result1 * result1;
                total_squared_value_thread2 += result2 * result2;
            }
            else
            {
                std::cout << "Error generating random point." << std::endl;
                i--;
            }
        }

#pragma omp critical
        {
            total_value1 += total_value_thread1;
            total_value2 += total_value_thread2;
            total_squared_value1 += total_squared_value_thread1;
            total_squared_value2 += total_squared_value_thread2;
        }
    }

    total_squared_value = total_squared_value1 + total_squared_value2;
    total_value = total_value1 + total_value2;
    result1 = total_value1 / static_cast<double>(points/2);
    result2 = total_value2 / static_cast<double>(points/2);
    C = (result1 + result2) / 2.0;
    C0 = C * exp(-r*T);

    // Calculate the variance
    variance = total_squared_value / static_cast<double>(points) - (total_value / static_cast<double>(points)) * (total_value / static_cast<double>(points));

    // Stop the timer
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    return std::make_pair(C0, static_cast<double>(duration.count()));
}

// Function to generate a random point
void generateRandomPoint(std::vector<double> &random_point1,
                        std::vector<double> &random_point2,
                         const std::vector<const Asset *> &assetPtrs,
                         const double std_dev_from_mean,
                         std::vector<double> &predicted_assets_prices)
{
    uint num_days_to_simulate = 252;
    double T = 1.0;
    double dt = T / num_days_to_simulate;
    uint32_t seed = 123456789;
    try
    {
        thread_local std::mt19937 eng(xorshift(seed));

#pragma omp parallel for
        for (size_t i = 0; i < assetPtrs.size(); ++i)
        {
            // Geometry Brownian Motion price:
            std::normal_distribution<double> distribution(0, 1);
            double prices1[num_days_to_simulate + 1]; // = prices[num_days_to_simulate*fraction_of_day_of_each_step];
            double prices2[num_days_to_simulate + 1];
            double asian_prices = 0.0;
            prices1[0] = assetPtrs[i]->getLastRealValue();
            prices2[0] = assetPtrs[i]->getLastRealValue();
            for (uint step = 1; step < num_days_to_simulate + 1; ++step)
            {
                double randNorm = distribution(eng);
                prices1[step] = prices1[step - 1] * exp((assetPtrs[i]->getReturnMean() - 0.5 * assetPtrs[i]->getReturnStdDev() *
                                                                                           assetPtrs[i]->getReturnStdDev()) *
                                                          dt +
                                                      assetPtrs[i]->getReturnStdDev() * sqrt(dt) * randNorm);
                prices2[step] = prices2[step - 1] * exp((assetPtrs[i]->getReturnMean() - 0.5 * assetPtrs[i]->getReturnStdDev() *
                                                                                           assetPtrs[i]->getReturnStdDev()) *
                                                          dt +
                                                      assetPtrs[i]->getReturnStdDev() * sqrt(dt) * randNorm);
                if (step % 21 == 0)
                {
                    asian_prices += prices1[step] / prices1[0];
                }
            }

#pragma omp critical
            {
                //random_point[i] = asian_prices;
                random_point1[i] = prices1[num_days_to_simulate];
                random_point2[i] = prices2[num_days_to_simulate];
                predicted_assets_prices[i] += prices1[num_days_to_simulate];
            }
        }
    }
    catch (const std::exception &e)
    {
        std::cerr << "Error occurred: " << e.what() << std::endl;
        random_point1.clear();
        random_point2.clear();
    }
}